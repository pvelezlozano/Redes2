<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>Introduction</title><link rel="stylesheet" type="text/css" href="/+static/base.css"/><link rel="stylesheet" type="text/css" href="/+static/doc.css"/><link rel="stylesheet" type="text/css" href="/+static/prettify/prettify.css"/><!-- default customHeadTagPart --></head><body class="Site"><header class="Site-header "><div class="Header"><div class="Header-title"></div></div></header><div class="Site-content Site-Content--markdown"><div class="Container"><div class="doc"><h1><a class="h" name="Introduction" href="#Introduction"><span></span></a><a class="h" name="introduction" href="#introduction"><span></span></a>Introduction</h1><p>Given a minidump file, the Breakpad processor produces stack traces that include function names and source locations. However, minidump files contain only the byte-by-byte contents of threads&#39; registers and stacks, without function names or machine-code-to-source mapping data. The processor consults Breakpad symbol files for the information it needs to produce human-readable stack traces from the binary-only minidump file.</p><p>The platform-specific symbol dumping tools parse the debugging information the compiler provides (whether as DWARF or STABS sections in an ELF file or as stand-alone PDB files), and write that information back out in the Breakpad symbol file format. This format is much simpler and less detailed than compiler debugging information, and values legibility over compactness.</p><h1><a class="h" name="Overview" href="#Overview"><span></span></a><a class="h" name="overview" href="#overview"><span></span></a>Overview</h1><p>Breakpad symbol files are ASCII text files, with lines delimited as appropriate for the host platform. Each line is a <em>record</em>, divided into fields by single spaces; in some cases, the last field of the record can contain spaces. The first field is a string indicating what sort of record the line represents (except for line records; these are very common, making them the default saves space). Some fields hold decimal or hexadecimal numbers; hexadecimal numbers have no &ldquo;0x&rdquo; prefix, and use lower-case letters.</p><p>Breakpad symbol files contain the following record types. With some restrictions, these may appear in any order.</p><ul><li><p>A <code class="code">MODULE</code> record describes the executable file or shared library from which this data was derived, for use by symbol suppliers. A `MODULE&#39; record should be the first record in the file.</p></li><li><p>A <code class="code">FILE</code> record gives a source file name, and assigns it a number by which other records can refer to it.</p></li><li><p>A <code class="code">FUNC</code> record describes a function present in the source code.</p></li><li><p>A line record indicates to which source file and line a given range of machine code should be attributed. The line is attributed to the function defined by the most recent <code class="code">FUNC</code> record.</p></li><li><p>A <code class="code">PUBLIC</code> record gives the address of a linker symbol.</p></li><li><p>A <code class="code">STACK</code> record provides information necessary to produce stack traces.</p></li></ul><h1><a class="h" name="records-1" href="#records-1"><span></span></a><code class="code">MODULE</code> records</h1><p>A <code class="code">MODULE</code> record provides meta-information about the module the symbol file describes. It has the form:</p><blockquote><p><code class="code">MODULE</code> <em>operatingsystem</em> <em>architecture</em> <em>id</em> <em>name</em></p></blockquote><p>For example: <code class="code">MODULE Linux x86 D3096ED481217FD4C16B29CD9BC208BA0 firefox-bin</code> These records provide meta-information about the executable or shared library from which this symbol file was generated. A symbol supplier might use this information to find the correct symbol files to use to interpret a given minidump, or to perform other sorts of validation. If present, a <code class="code">MODULE</code> record should be the first line in the file.</p><p>The fields are separated by spaces, and cannot contain spaces themselves, except for <em>name</em>.</p><ul><li><p>The <em>operatingsystem</em> field names the operating system on which the executable or shared library was intended to run. This field should have one of the following values: | <strong>Value</strong> | <strong>Meaning</strong> | |:----------|:--------------------| | Linux | Linux | | mac | Macintosh OSX | | windows | Microsoft Windows |</p></li><li><p>The <em>architecture</em> field indicates what processor architecture the executable or shared library contains machine code for. This field should have one of the following values: | <strong>Value</strong> | <strong>Instruction Set Architecture</strong> | |:----------|:---------------------------------| | x86 | Intel IA-32 | | x86_64 | AMD64/Intel 64 | | ppc | 32-bit PowerPC | | ppc64 | 64-bit PowerPC | | unknown | unknown |</p></li><li><p>The <em>id</em> field is a sequence of hexadecimal digits that identifies the exact executable or library whose contents the symbol file describes. The way in which it is computed varies from platform to platform.</p></li><li><p>The <em>name</em> field contains the base name (the final component of the directory path) of the executable or library. It may contain spaces, and extends to the end of the line.</p></li></ul><h1><a class="h" name="records-2" href="#records-2"><span></span></a><code class="code">FILE</code> records</h1><p>A <code class="code">FILE</code> record holds a source file name for other records to refer to. It has the form:</p><blockquote><p><code class="code">FILE</code> <em>number</em> <em>name</em></p></blockquote><p>For example: <code class="code">FILE 2 /home/jimb/mc/in/browser/app/nsBrowserApp.cpp</code></p><p>A <code class="code">FILE</code> record provides the name of a source file, and assigns it a number which other records (line records, in particular) can use to refer to that file name. The <em>number</em> field is a decimal number. The <em>name</em> field is the name of the file; it may contain spaces.</p><h1><a class="h" name="records-3" href="#records-3"><span></span></a><code class="code">FUNC</code> records</h1><p>A <code class="code">FUNC</code> record describes a source-language function. It has the form:</p><blockquote><p><code class="code">FUNC</code> <em>[m]</em> <em>address</em> <em>size</em> <em>parameter_size</em> <em>name</em></p></blockquote><p>For example: <code class="code">FUNC m c184 30 0 nsQueryInterfaceWithError::operator()(nsID const&amp;, void**) const</code></p><p>The <em>m</em> field is optional. If present it indicates that multiple symbols reference this function&#39;s instructions. (In which case, only one symbol name is mentioned within the breakpad file.) Multiple symbols referencing the same instructions may occur due to identical code folding by the linker.</p><p>The <em>address</em> and <em>size</em> fields are hexadecimal numbers indicating the start address and length in bytes of the machine code instructions the function occupies. (Breakpad symbol files cannot accurately describe functions whose code is not contiguous.) The start address is relative to the module&#39;s load address.</p><p>The <em>parameter_size</em> field is a hexadecimal number indicating the size, in bytes, of the arguments pushed on the stack for this function. Some calling conventions, like the Microsoft Windows <code class="code">stdcall</code> convention, require the called function to pop parameters passed to it on the stack from its caller before returning. The stack walker uses this value, along with data from <code class="code">STACK</code> records, to step from the called function&lsquo;s frame to the caller&rsquo;s frame.</p><p>The <em>name</em> field is the name of the function. In languages that use linker symbol name mangling like C++, this should be the source language name (the &ldquo;unmangled&rdquo; form). This field may contain spaces.</p><h1><a class="h" name="Line-records" href="#Line-records"><span></span></a><a class="h" name="line-records" href="#line-records"><span></span></a>Line records</h1><p>A line record describes the source file and line number to which a given range of machine code should be attributed. It has the form:</p><blockquote><p><em>address</em> <em>size</em> <em>line</em> <em>filenum</em></p></blockquote><p>For example: <code class="code">c184 7 59 4</code></p><p>Because they are so common, line records do not begin with a string indicating the record type. All other record types&#39; names use upper-case letters; hexadecimal numbers, like a line record&#39;s <em>address</em>, use lower-case letters.</p><p>The <em>address</em> and <em>size</em> fields are hexadecimal numbers indicating the start address and length in bytes of the machine code. The address is relative to the module&#39;s load address.</p><p>The <em>line</em> field is the line number to which the machine code should be attributed, in decimal; the first line of the source file is line number 1. The <em>filenum</em> field is a decimal number appearing in a prior <code class="code">FILE</code> record; the name given in that record is the source file name for the machine code.</p><p>The line is assumed to belong to the function described by the last preceding <code class="code">FUNC</code> record. Line records may not appear before the first `FUNC&#39; record.</p><p>No two line records in a symbol file cover the same range of addresses. However, there may be many line records with identical line and file numbers, as a given source line may contribute many non-contiguous blocks of machine code.</p><h1><a class="h" name="records-4" href="#records-4"><span></span></a><code class="code">PUBLIC</code> records</h1><p>A <code class="code">PUBLIC</code> record describes a publicly visible linker symbol, such as that used to identify an assembly language entry point or region of memory. It has the form:</p><blockquote><p>PUBLIC <em>[m]</em> <em>address</em> <em>parameter_size</em> <em>name</em></p></blockquote><p>For example: <code class="code">PUBLIC m 2160 0 Public2_1</code></p><p>The Breakpad processor essentially treats a <code class="code">PUBLIC</code> record as defining a function with no line number data and an indeterminate size: the code extends to the next address mentioned. If a given address is covered by both a <code class="code">PUBLIC</code> record and a <code class="code">FUNC</code> record, the processor uses the <code class="code">FUNC</code> data.</p><p>The <em>m</em> field is optional. If present it indicates that multiple symbols reference this function&#39;s instructions. (In which case, only one symbol name is mentioned within the breakpad file.) Multiple symbols referencing the same instructions may occur due to identical code folding by the linker.</p><p>The <em>address</em> field is a hexadecimal number indicating the symbol&lsquo;s address, relative to the module&rsquo;s load address.</p><p>The <em>parameter_size</em> field is a hexadecimal number indicating the size of the parameters passed to the code whose entry point the symbol marks, if known. This field has the same meaning as the <em>parameter_size</em> field of a <code class="code">FUNC</code> record; see that description for more details.</p><p>The <em>name</em> field is the name of the symbol. In languages that use linker symbol name mangling like C++, this should be the source language name (the &ldquo;unmangled&rdquo; form). This field may contain spaces.</p><h1><a class="h" name="records-5" href="#records-5"><span></span></a><code class="code">STACK WIN</code> records</h1><p>Given a stack frame, a <code class="code">STACK WIN</code> record indicates how to find the frame that called it. It has the form:</p><blockquote><p>STACK WIN <em>type</em> <em>rva</em> <em>code_size</em> <em>prologue_size</em> <em>epilogue_size</em> <em>parameter_size</em> <em>saved_register_size</em> <em>local_size</em> <em>max_stack_size</em> <em>has_program_string</em> <em>program_string_OR_allocates_base_pointer</em></p></blockquote><p>For example: <code class="code">STACK WIN 4 2170 14 1 0 0 0 0 0 1 $eip 4 + ^ = $esp $ebp 8 + = $ebp $ebp ^ =</code></p><p>All fields of a <code class="code">STACK WIN</code> record, except for the last, are hexadecimal numbers.</p><p>The <em>type</em> field indicates what sort of stack frame data this record holds. Its value should be one of the values of the <a href="http://msdn.microsoft.com/en-us/library/bc5207xw%28VS.100%29.aspx">StackFrameTypeEnum</a> type in Microsoft&#39;s <a href="http://msdn.microsoft.com/en-us/library/x93ctkx8%28VS.100%29.aspx">Debug Interface Access (DIA)</a> API. Breakpad uses only records of type 4 (<code class="code">FrameTypeFrameData</code>) and 0 (<code class="code">FrameTypeFPO</code>); it ignores others. These types differ only in whether the last field is an <em>allocates_base_pointer</em> flag (<code class="code">FrameTypeFPO</code>) or a program string (<code class="code">FrameTypeFrameData</code>). If more than one record covers a given address, Breakpad prefers <code class="code">FrameTypeFrameData</code> records over <code class="code">FrameTypeFPO</code> records.</p><p>The <em>rva</em> and <em>code_size</em> fields give the starting address and length in bytes of the machine code covered by this record. The starting address is relative to the module&#39;s load address.</p><p>The <em>prologue_size</em> and <em>epilogue_size</em> fields give the length, in bytes, of the prologue and epilogue machine code within the record&#39;s range. Breakpad does not use these values.</p><p>The <em>parameter_size</em> field gives the number of argument bytes this function expects to have been passed. This field has the same meaning as the <em>parameter_size</em> field of a <code class="code">FUNC</code> record; see that description for more details.</p><p>The <em>saved_register_size</em> field gives the number of bytes in the stack frame dedicated to preserving the values of any callee-saves registers used by this function.</p><p>The <em>local_size</em> field gives the number of bytes in the stack frame dedicated to holding the function&#39;s local variables and temporary values.</p><p>The <em>max_stack_size</em> field gives the maximum number of bytes pushed on the stack in the frame. Breakpad does not use this value.</p><p>If the <em>has_program_string</em> field is zero, then the <code class="code">STACK WIN</code> record&#39;s final field is an <em>allocates_base_pointer</em> flag, as a hexadecimal number; this is expected for records whose <em>type</em> is 0. Otherwise, the final field is a program string.</p><h2><a class="h" name="Interpreting-a-record" href="#Interpreting-a-record"><span></span></a><a class="h" name="interpreting-a-record" href="#interpreting-a-record"><span></span></a>Interpreting a <code class="code">STACK WIN</code> record</h2><p>Given the register values for a frame F, we can find the calling frame as follows:</p><ul><li>If the <em>has_program_string</em> field of a <code class="code">STACK WIN</code> record is zero, then the final field is <em>allocates_base_pointer</em>, a flag indicating whether the frame uses the frame pointer register, <code class="code">%ebp</code>, as a general-purpose register.<ul><li>If <em>allocates_base_pointer</em> is true, then <code class="code">%ebp</code> does not point to the frame&#39;s base address. Instead,<ul><li>Let <em>next_parameter_size</em> be the parameter size of the function frame F called (<strong>not</strong> this record&lsquo;s <em>parameter_size</em> field), or zero if F is the youngest frame on the stack. You must find this value in F&rsquo;s callee&#39;s <code class="code">FUNC</code>, <code class="code">STACK WIN</code>, or <code class="code">PUBLIC</code> records.</li><li>Let <em>frame_size</em> be the sum of the <em>local_size</em> field, the <em>saved_register_size</em> field, and <em>next_parameter_size</em>. &gt; &gt; With those definitions in place, we can recover the calling frame as follows:</li><li>F&#39;s return address is at <code class="code">%esp +</code><em>frame_size</em>,</li><li>the caller&#39;s value of <code class="code">%ebp</code> is saved at <code class="code">%esp +</code><em>next_parameter_size</em><code class="code">+</code><em>saved_register_size</em><code class="code">- 8</code>, and</li><li>the caller&lsquo;s value of <code class="code">%esp</code> just before the call instruction was <code class="code">%esp +</code><em>frame_size</em><code class="code">+ 4</code>. &gt; &gt; (Why do we include <em>next_parameter_size</em> in the sum when computing <em>frame_size</em> and the address of the saved <code class="code">%ebp</code>? When a function A has called a function B, the arguments that A pushed for B are considered part of A&rsquo;s stack frame: A&lsquo;s value for <code class="code">%esp</code> points at the last argument pushed for B. Thus, we must include the size of those arguments (given by the debugging info for B) along with the size of A&rsquo;s register save area and local variable area (given by the debugging info for A) when computing the overall size of A&#39;s frame.)</li></ul></li><li>If <em>allocates_base_pointer</em> is false, then F&lsquo;s function doesn&rsquo;t use <code class="code">%ebp</code> at all. You may recover the calling frame as above, except that the caller&lsquo;s value of <code class="code">%ebp</code> is the same as F&rsquo;s value for <code class="code">%ebp</code>, so no steps are necessary to recover it.</li></ul></li><li>If the <em>has_program_string</em> field of a <code class="code">STACK WIN</code> record is not zero, then the record&lsquo;s final field is a string containing a program to be interpreted to recover the caller&rsquo;s frame. The comments in the <a href="/breakpad/breakpad/+/master/src/processor/postfix_evaluator.h#40">postfix_evaluator.h</a> header file explain the language in which the program is written. You should place the following variables in the dictionary before interpreting the program:<ul><li><code class="code">$ebp</code> and <code class="code">$esp</code> should be the values of the <code class="code">%ebp</code> and <code class="code">%esp</code> registers in F.</li><li><code class="code">.cbParams</code>, <code class="code">.cbSavedRegs</code>, and <code class="code">.cbLocals</code>, should be the values of the <code class="code">STACK WIN</code> record&#39;s <em>parameter_size</em>, <em>saved_register_size</em>, and <em>local_size</em> fields.</li><li><code class="code">.raSearchStart</code> should be set to the address on the stack to begin scanning for a return address, if necessary. The Breakpad processor sets this to the value of <code class="code">%esp</code> in F, plus the <em>frame_size</em> value mentioned above.</li></ul></li></ul><blockquote><p>If the program stores values for <code class="code">$eip</code>, <code class="code">$esp</code>, <code class="code">$ebp</code>, <code class="code">$ebx</code>, <code class="code">$esi</code>, or <code class="code">$edi</code>, then those are the values of the given registers in the caller. If the value of <code class="code">$eip</code> is zero, that indicates that the end of the stack has been reached.</p></blockquote><p>The Breakpad processor checks that the value yielded by the above for the calling frame&lsquo;s instruction address refers to known code; if the address seems to be bogus, then it uses a heuristic search to find F&rsquo;s return address and stack base.</p><h1><a class="h" name="records-6" href="#records-6"><span></span></a><code class="code">STACK CFI</code> records</h1><p><code class="code">STACK CFI</code> (&ldquo;Call Frame Information&rdquo;) records describe how to walk the stack when execution is at a given machine instruction. These records take one of two forms:</p><blockquote><p><code class="code">STACK CFI INIT</code> <em>address</em> <em>size</em> <em>register1</em>: <em>expression1</em> <em>register2</em>: <em>expression2</em> ...</p><p><code class="code">STACK CFI</code> <em>address</em> <em>register1</em>: <em>expression1</em> <em>register2</em>: <em>expression2</em> ...</p></blockquote><p>For example:</p><pre class="code">STACK CFI INIT 804c4b0 40 .cfa: $esp 4 + $eip: .cfa 4 - ^
STACK CFI 804c4b1 .cfa: $esp 8 + $ebp: .cfa 8 - ^
</pre><p>The <em>address</em> and <em>size</em> fields are hexadecimal numbers. Each <em>register</em>i is the name of a register or pseudoregister. Each <em>expression</em> is a Breakpad postfix expression, which may contain spaces, but never ends with a colon. (The appropriate register names for a given architecture are determined when <code class="code">STACK CFI</code> records are first enabled for that architecture, and should be documented in the appropriate <code class="code">stackwalker_</code><em>architecture</em><code class="code">.cc</code> source file.)</p><p>STACK CFI records describe, at each machine instruction in a given function, how to recover the values the machine registers had in the function&lsquo;s caller. Naturally, some registers&rsquo; values are simply lost, but there are three cases in which they can be recovered:</p><ul><li><p>You can always recover the program counter, because that&lsquo;s the function&rsquo;s return address. If the function is ever going to return, the PC must be saved somewhere.</p></li><li><p>You can always recover the stack pointer. The function is responsible for popping its stack frame before it returns to the caller, so it must be able to restore this, as well.</p></li><li><p>You should be able to recover the values of callee-saves registers. These are registers whose values the callee must preserve, either by saving them in its own stack frame before using them and re-loading them before returning, or by not using them at all.</p></li></ul><p>(As an exception, note that functions which never return may not save any of this data. It may not be possible to walk the stack past such functions&#39; stack frames.)</p><p>Given rules for recovering the values of a function&lsquo;s caller&rsquo;s registers, we can walk up the stack. Starting with the current set of registers --- the PC of the instruction we&lsquo;re currently executing, the current stack pointer, etc. --- we use CFI to recover the values those registers had in the caller of the current frame. This gives us a PC in the caller whose CFI we can look up; we apply the process again to find that function&rsquo;s caller; and so on.</p><p>Concretely, CFI records represent a table with a row for each machine instruction address and a column for each register. The table entry for a given address and register contains a rule describing how, when the PC is at that address, to restore the value that register had in the caller.</p><p>There are some special columns:</p><ul><li><p>A column named <code class="code">.cfa</code>, for &ldquo;Canonical Frame Address&rdquo;, tells how to compute the base address of the frame; other entries can refer to the CFA in their rules.</p></li><li><p>A column named <code class="code">.ra</code> represents the return address.</p></li></ul><p>For example, suppose we have a machine with 32-bit registers, one-byte instructions, a stack that grows downwards, and an assembly language that resembles C. Suppose further that we have a function whose machine code looks like this:</p><pre class="code">func:                                ; entry point; return address at sp
func+0:      sp -= 16                ; allocate space for stack frame
func+1:      sp[12] = r0             ; save 4-byte r0 at sp+12
             ...                     ; stuff that doesn&#39;t affect stack
func+10:     sp -= 4; *sp = x        ; push some 4-byte x on the stack
             ...                     ; stuff that doesn&#39;t affect stack
func+20:     r0 = sp[16]             ; restore saved r0
func+21:     sp += 20                ; pop whole stack frame
func+22:     pc = *sp; sp += 4       ; pop return address and jump to it
</pre><p>The following table would describe the function above:</p><p><strong>code address</strong> | <strong>.cfa</strong> | <strong>r0 (on Google Code)</strong> | <strong>r1 (on Google Code)</strong> | ... | <strong>.ra</strong> :--------------- | :------- | :---------------------- | :---------------------- | :-- | :------- func+0           | sp       |                         |                         |     | <code class="code">cfa[0]</code> func+1           | sp+16    |                         |                         |     | <code class="code">cfa[0]</code> func+2           | sp+16    | <code class="code">cfa[-4]</code>               |                         |     | <code class="code">cfa[0]</code> func+11          | sp+20    | <code class="code">cfa[-4]</code>               |                         |     | <code class="code">cfa[0]</code> func+21          | sp+20    |                         |                         |     | <code class="code">cfa[0]</code> func+22          | sp       |                         |                         |     | <code class="code">cfa[0]</code></p><p>Some things to note here:</p><ul><li><p>Each row describes the state of affairs <strong>before</strong> executing the instruction at the given address. Thus, the row for func+0 describes the state before we execute the first instruction, which allocates the stack frame. In the next row, the formula for computing the CFA has changed, reflecting the allocation.</p></li><li><p>The other entries are written in terms of the CFA; this allows them to remain unchanged as the stack pointer gets bumped around. For example, to find the caller&#39;s value for r0 (on Google Code) at func+2, we would first compute the CFA by adding 16 to the sp, and then subtract four from that to find the address at which r0 (on Google Code) was saved.</p></li><li><p>Although the example doesn&lsquo;t show this, most calling conventions designate &ldquo;callee-saves&rdquo; and &ldquo;caller-saves&rdquo; registers. The callee must restore the values of &ldquo;callee-saves&rdquo; registers before returning (if it uses them at all), whereas the callee is free to use &ldquo;caller-saves&rdquo; registers without restoring their values. A function that uses caller-saves registers typically does not save their original values at all; in this case, the CFI marks such registers&rsquo; values as &ldquo;unrecoverable&rdquo;.</p></li><li><p>Exactly where the CFA points in the frame --- at the return address? below it? At some fixed point within the frame? --- is a question of definition that depends on the architecture and ABI in use. But by definition, the CFA remains constant throughout the lifetime of the frame. It&#39;s up to architecture- specific code to know what significance to assign the CFA, if any.</p></li></ul><p>To save space, the most common type of CFI record only mentions the table entries at which changes take place. So for the above, the CFI data would only actually mention the non-blank entries here:</p><p><strong>insn</strong> | <strong>cfa</strong> | <strong>r0 (on Google Code)</strong> | <strong>r1 (on Google Code)</strong> | ... | <strong>ra</strong> :------- | :------ | :---------------------- | :---------------------- | :-- | :------- func+0   | sp      |                         |                         |     | <code class="code">cfa[0]</code> func+1   | sp+16   |                         |                         |     | func+2   |         | <code class="code">cfa[-4]</code>               |                         |     | func+11  | sp+20   |                         |                         |     | func+21  |         | r0 (on Google Code)     |                         |     | func+22  | sp      |                         |                         |     |</p><p>A <code class="code">STACK CFI INIT</code> record indicates that, at the machine instruction at <em>address</em>, belonging to some function, the value that <em>registern</em> had in that function&lsquo;s caller can be recovered by evaluating <em>expressionn</em>. The values of any callee-saves registers not mentioned are assumed to be unchanged. (<code class="code">STACK CFI</code> records never mention caller-saves registers.) These rules apply starting at <em>address</em> and continue up to, but not including, the address given in the next <code class="code">STACK CFI</code> record. The <em>size</em> field is the total number of bytes of machine code covered by this record and any subsequent <code class="code">STACK CFI</code> records (until the next <code class="code">STACK CFI INIT</code> record). The <em>address</em> field is relative to the module&rsquo;s load address.</p><p>A <code class="code">STACK CFI</code> record (no <code class="code">INIT</code>) is the same, except that it mentions only those registers whose recovery rules have changed from the previous CFI record. There must be a prior <code class="code">STACK CFI INIT</code> or <code class="code">STACK CFI</code> record in the symbol file. The <em>address</em> field of this record must be greater than that of the previous record, and it must not be at or beyond the end of the range given by the most recent <code class="code">STACK CFI INIT</code> record. The address is relative to the module&#39;s load address.</p><p>Each expression is a breakpad-style postfix expression. Expressions may contain spaces, but their tokens may not end with colons. When an expression mentions a register, it refers to the value of that register in the callee, even if a prior name/expression pair gives that register&#39;s value in the caller. The exception is <code class="code">.cfa</code>, which refers to the canonical frame address computed by the .cfa rule in force at the current instruction.</p><p>The special expression <code class="code">.undef</code> indicates that the given register&#39;s value cannot be recovered.</p><p>The register names preceding the expressions are always followed by colons. The expressions themselves never contain tokens ending with colons.</p><p>There are two special register names:</p><ul><li><p><code class="code">.cfa</code> (&ldquo;Canonical Frame Address&rdquo;) is the base address of the stack frame. Other registers&#39; rules may refer to this. If no rule is provided for the stack pointer, the value of <code class="code">.cfa</code> is the caller&#39;s stack pointer.</p></li><li><p><code class="code">.ra</code> is the return address. This is the value of the restored program counter. We use <code class="code">.ra</code> instead of the architecture-specific name for the program counter.</p></li></ul><p>The Breakpad stack walker requires that there be rules in force for <code class="code">.cfa</code> and <code class="code">.ra</code> at every code address from which it unwinds. If those rules are not present, the stack walker will ignore the <code class="code">STACK CFI</code> data, and try to use a different strategy.</p><p>So the CFI for the example function above would be as follows, if <code class="code">func</code> were at address 0x1000 (relative to the module&#39;s load address):</p><pre class="code">STACK CFI INIT 1000 .cfa: $sp .ra: .cfa ^
STACK CFI      1001 .cfa: $sp 16 +
STACK CFI      1002 $r0: .cfa 4 - ^
STACK CFI      100b .cfa: $sp 20 +
STACK CFI      1015 $r0: $r0
STACK CFI      1016 .cfa: $sp
</pre></div></div></div><!-- default customFooter --><footer class="Site-footer"><div class="Footer"><span class="Footer-poweredBy">Powered by <a href="https://gerrit.googlesource.com/gitiles/">Gitiles</a>| <a href="https://policies.google.com/privacy">Privacy</a></span><div class="Footer-links"></div></div></footer><script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date; ga('create', 'UA-55762617-15', 'auto'); ga('send', 'pageview', {title: 'Introduction'});</script><script async src="https://www.google-analytics.com/analytics.js"></script></body></html>